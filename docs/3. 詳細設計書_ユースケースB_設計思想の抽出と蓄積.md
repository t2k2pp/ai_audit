# **詳細設計書：ユースケースB（設計思想のリバースエンジニアリングと蓄積）**

**対象モジュール:** CLIバッチツール 兼 検索用API

**対象言語 (MVP想定):** Python (AST解析とベクトルDBの親和性が高いため)

**目的:** ソースコードの関数・クラス単位の実装から「なぜそのように書かれたか（業務的意図・技術的妥協）」をAIに推測させ、ベクトルデータベースに蓄積してRAG（検索拡張生成）の基盤とする。

## **1\. 処理シーケンス（データフロー）**

本ユースケースは「抽出バッチ処理」と「検索処理」の2つの独立したフェーズで構成される。

### **1.1. 抽出フェーズ（バッチ実行）**

1. **\[トリガー\]** 開発者がCLIで特定のディレクトリを指定してコマンドを実行（例: extract\_why ./src）、またはCI/CDパイプラインの定期ジョブとして起動する。  
2. **\[解析と分割\]** ast ライブラリを使用してソースコードを解析し、関数（FunctionDef）およびクラス（ClassDef）単位でコード文字列を抽出する。  
3. **\[推論実行\]** 抽出したチャンクごとに、AIへ「設計思想抽出ウェア（システムプロンプト）」を適用し、APIリクエストを送信する。  
4. **\[ベクトル化・保存\]** AIが生成した「意図（Why）の解説テキスト」を、Embedding API（テキストを数値ベクトルに変換するAPI）に送信し、ベクトルデータ化する。  
5. **\[蓄積\]** ベクトルデータとメタデータ（ファイルパス、関数名）を、ローカルのベクトルデータベース（ChromaDB等）に保存する。

### **1.2. 検索フェーズ（オンデマンド実行）**

1. **\[トリガー\]** 開発者がCLI等で自然言語による質問を入力（例: search\_why "古い課金APIの仕様に合わせている部分はどこ？"）。  
2. **\[ベクトル検索\]** 質問テキストをEmbeddingし、ベクトルデータベースに対して類似度検索（Cosine Similarity等）を実行。関連性の高い「設計思想の解説テキスト」と「メタデータ」をTop-K件取得し、回答として提示する。

## **2\. ウェア（プロンプト）設計定義**

「コードが何をしているか」ではなく、「背景にある理由」を推測させることに特化したプロンプト。

### **ウェア: 設計思想・技術的負債アナリスト**

* **システムプロンプト例:**  
  あなたは優秀なソフトウェアアーキテクトです。  
  提供されたコード片を読み、コードの挙動（What）ではなく、その裏にある「設計思想」や「業務上の意図（Why）」を推論して日本語で説明してください。

  以下の観点でおそらく該当するものを推測してください：  
  1\. なぜこの実装アプローチが選ばれたのか（パフォーマンス優先、可読性優先など）。  
  2\. 他のAPIやレガシーシステムとの互換性のために、あえて不自然な実装（技術的負債）を行っている形跡はないか。  
  3\. この関数が解決しようとしているビジネス上の課題は何か。

  コード片のみから確実なことが言えない場合でも、プロフェッショナルとしての推論を記述してください。

## **3\. ベクトルデータベース スキーマ設計（ChromaDB想定）**

リレーショナルデータベースではなく、意味検索が可能なベクトルストアを利用する。

**コレクション: architecture\_decisions**

* id (String): 一意識別子（例: ファイルパス:関数名）  
* embedding (Vector): 生成された解説テキストのベクトル値  
* document (String): AIが生成した「意図（Why）」の解説テキスト全文  
* metadata (JSON):  
  * file\_path: 元ファイルの相対パス  
  * function\_name: 関数・クラス名  
  * extracted\_at: 抽出実行日時